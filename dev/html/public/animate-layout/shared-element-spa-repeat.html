<html>
    <!--
     Test for stale shared layout nodes across SPA navigations.
     Verifies that resumeFrom is not set to disconnected instances and
     that the stack maintains correct references through multiple navigations.
    -->
    <head>
        <style>
            body {
                padding: 0;
                margin: 0;
            }

            #container {
                width: 400px;
                height: 400px;
                background-color: #f0f0f0;
                position: relative;
            }

            .card {
                position: absolute;
                background-color: #00cc88;
            }

            .card.small {
                top: 0;
                left: 0;
                width: 100px;
                height: 100px;
            }

            .card.big {
                top: 200px;
                left: 200px;
                width: 200px;
                height: 200px;
                background-color: #09f;
            }

            [data-layout-correct="false"] {
                background: #dd1144 !important;
                opacity: 0.5;
            }
        </style>
    </head>
    <body>
        <div id="container"></div>

        <script type="module" src="/src/imports/projection.js"></script>
        <script type="module" src="/src/imports/script-animate.js"></script>
        <script type="module" src="/src/imports/script-assert.js"></script>
        <script type="module">
            const { createNode } = window.Animate
            const container = document.getElementById("container")

            // Root projection node for shared layout tracking
            const root = createNode(container, undefined, { layout: true })

            // Simulate first navigation: create element then remove from DOM without cleanup
            const staleElement = document.createElement("div")
            staleElement.className = "card small"
            staleElement.setAttribute("data-layout-id", "hero")
            container.appendChild(staleElement)
            const staleNode = createNode(staleElement, root, {
                layoutId: "hero",
            })

            // Simulate navigation away: DOM removed but projection node remains in stack
            staleElement.remove()

            // Simulate second navigation: create exiting element
            const exitingElement = document.createElement("div")
            exitingElement.className = "card small"
            exitingElement.setAttribute("data-layout-id", "hero")
            container.appendChild(exitingElement)
            const exitingNode = createNode(exitingElement, root, {
                layoutId: "hero",
            })

            // Mark as exiting and relegate to find previous valid state
            exitingNode.isPresent = false
            exitingNode.relegate()

            // Create current element that should animate from exiting state
            const currentElement = document.createElement("div")
            currentElement.className = "card big"
            currentElement.setAttribute("data-layout-id", "hero")
            container.appendChild(currentElement)
            const currentNode = createNode(currentElement, root, {
                layoutId: "hero",
            })

            // Test 1: resumeFrom should not point to disconnected stale node
            const resumeFrom = currentNode.resumeFrom
            const resumeFromConnected = Boolean(
                resumeFrom?.instance && resumeFrom.instance.isConnected
            )
            const resumeFromHasSnapshot = Boolean(resumeFrom?.snapshot)
            const resumeFromIsPresent = resumeFrom?.isPresent !== false

            // Invalid if: exists, marked as present, but disconnected and no snapshot
            const isInvalid =
                resumeFrom &&
                resumeFromIsPresent &&
                !resumeFromConnected &&
                !resumeFromHasSnapshot

            if (isInvalid) {
                currentElement.dataset.layoutCorrect = "false"
                console.error(
                    "resumeFrom points to disconnected zombie instance"
                )
            }

            // Test 2: Verify stack members array doesn't accumulate zombies
            // Access internal stack if exposed, or check via root
            const stack = currentNode.getStack?.() || currentNode.stack
            if (stack) {
                const zombies = stack.members.filter(
                    (m) =>
                        m.instance &&
                        m.instance.isConnected === false &&
                        !m.snapshot &&
                        m.isPresent !== false
                )

                if (zombies.length > 0) {
                    currentElement.dataset.layoutCorrect = "false"
                    console.error(
                        `Stack contains ${zombies.length} zombie nodes`
                    )
                }
            }

            // Test 3: Chain continuity - simulate third navigation
            // Remove current node and create a new one to verify the chain isn't broken
            if (currentNode.remove) currentNode.remove()

            const finalElement = document.createElement("div")
            finalElement.className = "card small"
            finalElement.setAttribute("data-layout-id", "hero")
            container.appendChild(finalElement)
            const finalNode = createNode(finalElement, root, {
                layoutId: "hero",
            })

            // Should animate from currentNode (the previous valid lead), not staleNode
            const finalResumeFrom = finalNode.resumeFrom
            const chainBroken =
                finalResumeFrom &&
                finalResumeFrom !== currentNode &&
                finalResumeFrom === staleNode

            if (chainBroken) {
                finalElement.dataset.layoutCorrect = "false"
                console.error(
                    "Chain broken: animating from stale node instead of previous"
                )
            }

            // Debug output for CI visibility
            window.__testResults = {
                resumeFromExists: Boolean(resumeFrom),
                resumeFromConnected,
                resumeFromHasSnapshot,
                isInvalid,
                zombieCount: stack
                    ? stack.members.filter(
                          (m) =>
                              m.instance &&
                              m.instance.isConnected === false &&
                              !m.snapshot &&
                              m.isPresent !== false
                      ).length
                    : -1,
                chainBroken,
            }
        </script>
    </body>
</html>
